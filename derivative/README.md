## üìÑ README: Optimally Rotation-Equivariant Derivative Filter Design

This repository contains MATLAB code for designing a family of derivative filters (kernels) that are robustly **rotation-equivariant**. This means that applying the filters and then rotating the image is mathematically equivalent to rotating the image and then applying the filters. This property is crucial for applications like robust feature detection in computer vision.

The core idea of the derivative detection system is to find a set of digital filters (kernels) that perform differentiation (find gradients) in a way that is mathematically robust under rotation. The design process uses a generalized eigenvector solution and non-linear optimization to minimize the error between the desired ideal frequency response and the response of the actual designed filters.

### ‚öôÔ∏è Core Files and Functionality

| File Name | Primary Function | Thought Process/Reasoning |
| :--- | :--- | :--- |
| `design_deriv.m` | **Main Design Script** | **Goal:** Design a set of $N$ filters (kernels) for a derivative of order $N$. The design is posed as a minimization problem where the filters must satisfy linear constraints (e.g., unit sum for the prefilter) and minimize a non-linear error function that measures deviation from an ideal frequency response and rotation invariance. It uses an SVD-based generalized eigenvector solution for the initial estimate. |
| `halftofull.m` | **HALF-TO-FULL CONVERSION** | **Goal:** Reconstruct the full 1-D filter coefficients (`u_full`) from the compact, optimized 'half' vector (`u_half`). **Reasoning:** Filters for even-order derivatives (like the prefilter) are **symmetric** (even), while filters for odd-order derivatives are **anti-symmetric** (odd). This function applies the correct symmetry/anti-symmetry rules (including handling the center tap for odd-length filters) to build the complete, physical filter kernel. |
| `fulltohalf.m` | **FULL-TO-HALF CONVERSION** | **Goal:** Convert the full filter coefficients to the compact 'half' representation (used internally for optimization, separating symmetric and anti-symmetric components). |
| `rot_invariance_err.m` | **Rotation Invariance Error** | **Goal:** Quantify the error in the rotation-equivariance property of the designed filters. **Reasoning:** The error measures the difference between the **rotated 2-D Fourier Transform** (of the filter product) and the **steered 2-D Fourier Transform** (a linear combination of the basis filter outputs). This checks if rotation and filtering are mathematically equivalent. |
| `deriv2_err.m` | **Second-Order Derivative Error** | **Goal:** Compute the error for the second-order derivative case ($N=2$) during the non-linear minimization step. **Reasoning:** The error is based on how well the calculated derivative responses in the frequency domain match the *ideal* derivative responses. It checks for consistency between the prefilter ($P$), the first derivative ($D_1$), and the second derivative ($D_2$) responses, especially in relation to the ideal frequency scaling ($\omega^2$). |
| `deriv3_err.m` | **Third-Order Derivative Error** | **Goal:** Compute the error for the third-order derivative case ($N=3$) during non-linear minimization. **Reasoning:** This function computes a complex error based on multiple consistency checks between the prefilter ($P$) and the derivative filters ($D_1, D_2, D_3$) across different orders of frequency response ($\omega, \omega^2, \omega^3$). |
| `showfilt.m` | **Visualization of Filters** | **Goal:** Plot the designed filter coefficients in the spatial domain using a stem plot for visual inspection. |
| `showfreq.m` | **Visualization of Frequency Response** | **Goal:** Plot the magnitude of the Fourier Transform of the designed filters. It compares the actual derivative response ($|D|$) to the ideal derivative response ($|\omega^k \cdot P|$) in the frequency domain. |
| `intersect.m` | **Geometric Subspace Intersection** | **Goal:** Find an orthonormal basis for the intersection of two subspaces. Used in the SVD step to find vectors in the null space of the error equation that also satisfy the linear constraints. |
| `rotate.m` | **Image/Map Rotation** | **Goal:** Rotate a 2-D input using interpolation (e.g., `'linear'`). Used internally to rotate the Fourier Transform for the `rot_invariance_err` calculation. |
| `solution10.mat` / `solution11.mat` | **Pre-Computed Solutions** | **Goal:** Load a pre-computed initial solution (`u10_half` or `u11_half`) for the filter coefficients, used to initialize the non-linear optimization. |

The detection of derivatives (image gradients) in this system works by creating filters that are optimally designed to isolate the high-frequency components that correspond to derivatives, while maintaining a smooth, desired response in the frequency domain.
